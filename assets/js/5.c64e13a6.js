(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{212:function(t,s,a){t.exports=a.p+"assets/img/knowledge_map.12bc9800.jpg"},213:function(t,s,a){t.exports=a.p+"assets/img/Von_Neumann_architecture.76984515.jpg"},214:function(t,s,a){t.exports=a.p+"assets/img/mips_instruction.b1ade5f8.jpeg"},215:function(t,s,a){t.exports=a.p+"assets/img/cpu_registers.cdba5c17.jpg"},216:function(t,s,a){t.exports=a.p+"assets/img/elf_format.276a740d.jpg"},217:function(t,s,a){t.exports=a.p+"assets/img/linker_process.f62da9b2.jpeg"},288:function(t,s,a){"use strict";a.r(s);var r=a(2),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"计算机组成原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算机组成原理"}},[t._v("#")]),t._v(" 计算机组成原理")]),t._v(" "),r("h2",{attrs:{id:"知识地图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#知识地图"}},[t._v("#")]),t._v(" 知识地图")]),t._v(" "),r("p",[r("img",{attrs:{src:a(212),alt:"知识图谱"}})]),t._v(" "),r("h2",{attrs:{id:"冯诺依曼体系结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#冯诺依曼体系结构"}},[t._v("#")]),t._v(" 冯诺依曼体系结构")]),t._v(" "),r("p",[r("img",{attrs:{src:a(213),alt:"冯诺依曼体系结构"}})]),t._v(" "),r("h2",{attrs:{id:"提高-cpu-性能的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#提高-cpu-性能的方式"}},[t._v("#")]),t._v(" 提高 CPU 性能的方式")]),t._v(" "),r("ol",[r("li",[t._v("增加 CPU 核心的数量，通过并行计算来提升性能")]),t._v(" "),r("li",[t._v("使用更先进的 CPU 制造工艺")]),t._v(" "),r("li",[t._v("加速大概率事件（比如机器学习中，99% 都是向量和矩阵计算）")]),t._v(" "),r("li",[t._v("通过流水线提高性能，拆分 CPU 指令执行的过程，细化运行")]),t._v(" "),r("li",[t._v("通过预测提高性能")])]),t._v(" "),r("h2",{attrs:{id:"mips-指令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mips-指令"}},[t._v("#")]),t._v(" MIPS 指令")]),t._v(" "),r("p",[r("img",{attrs:{src:a(214),alt:"MIPS 指令"}})]),t._v(" "),r("p",[t._v("MIPS 指令是一个 32 位的整数，高 6 位叫操作码，代表这条指令具体是一条什么样的指令。")]),t._v(" "),r("ul",[r("li",[t._v("R 指令一般用来做算数和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。")]),t._v(" "),r("li",[t._v("I 指令通常是用在数据传输、条件分支以及在运算的时候使用的并非变量而是常数。这个时候没有了位移量和功能码，也没有了第三个寄存器，而是把这三个部分直接合并成了一个地址值或者一个常数。")]),t._v(" "),r("li",[t._v("J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。")])]),t._v(" "),r("h2",{attrs:{id:"cpu-内部寄存器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-内部寄存器"}},[t._v("#")]),t._v(" CPU 内部寄存器")]),t._v(" "),r("p",[r("img",{attrs:{src:a(215),alt:"CPU 内部寄存器"}})]),t._v(" "),r("ul",[r("li",[t._v("条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if...else 以及 for/while 这样的程序控制流程。")])]),t._v(" "),r("h2",{attrs:{id:"elf-文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#elf-文件"}},[t._v("#")]),t._v(" ELF 文件")]),t._v(" "),r("p",[r("img",{attrs:{src:a(216),alt:"ELF 文件格式"}})]),t._v(" "),r("p",[t._v("链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后在根据重定位表，把所有不确定要跳转地址的代码，根据符号表里存储的地址，进行一个修正。最后，把所有目标文件的对应段进行一个合并，变成了最终的可执行文件。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(217),alt:"ELF 文件格式"}})]),t._v(" "),r("p",[t._v("装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。")]),t._v(" "),r("p",[t._v("Linux 下可执行文件的格式是 "),r("code",[t._v("ELF")]),t._v("，Windows 下可执行文件的格式是 "),r("code",[t._v("PE")]),t._v("， Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("Linux 下著名的开源软件 Wine，就是通过兼容 PE 格式装载器，使得我们能直接在 Linux 下运行 Windows 程序。")]),t._v(" "),r("p",[t._v("Windows 的 WSL 可以解析和加载 ELF 格式的文件。")])]),t._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.coursera.org/learn/jisuanji-zucheng",target:"_blank",rel:"noopener noreferrer"}},[t._v("coursera 公开课《计算机组成》"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.bilibili.com/video/av24540152/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSAPP 深入理解计算机系统"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);