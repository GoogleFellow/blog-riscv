(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{212:function(t,s,a){t.exports=a.p+"assets/img/knowledge_map.12bc9800.jpg"},213:function(t,s,a){t.exports=a.p+"assets/img/Von_Neumann_architecture.76984515.jpg"},214:function(t,s,a){t.exports=a.p+"assets/img/mips_instruction.b1ade5f8.jpeg"},215:function(t,s,a){t.exports=a.p+"assets/img/cpu_registers.cdba5c17.jpg"},216:function(t,s,a){t.exports=a.p+"assets/img/elf_format.276a740d.jpg"},217:function(t,s,a){t.exports=a.p+"assets/img/linker_process.f62da9b2.jpeg"},218:function(t,s,a){t.exports=a.p+"assets/img/memory_segmentation.57211af3.png"},219:function(t,s,a){t.exports=a.p+"assets/img/memory_paging.0cf2f08e.png"},220:function(t,s,a){t.exports=a.p+"assets/img/dynamic_link.8cab516a.jpeg"},291:function(t,s,a){"use strict";a.r(s);var r=a(2),_=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"计算机组成原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算机组成原理"}},[t._v("#")]),t._v(" 计算机组成原理")]),t._v(" "),r("h2",{attrs:{id:"知识地图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#知识地图"}},[t._v("#")]),t._v(" 知识地图")]),t._v(" "),r("p",[r("img",{attrs:{src:a(212),alt:"知识图谱"}})]),t._v(" "),r("h2",{attrs:{id:"冯诺依曼体系结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#冯诺依曼体系结构"}},[t._v("#")]),t._v(" 冯诺依曼体系结构")]),t._v(" "),r("p",[r("img",{attrs:{src:a(213),alt:"冯诺依曼体系结构"}})]),t._v(" "),r("h2",{attrs:{id:"提高-cpu-性能的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#提高-cpu-性能的方式"}},[t._v("#")]),t._v(" 提高 CPU 性能的方式")]),t._v(" "),r("ol",[r("li",[t._v("增加 CPU 核心的数量，通过并行计算来提升性能")]),t._v(" "),r("li",[t._v("使用更先进的 CPU 制造工艺")]),t._v(" "),r("li",[t._v("加速大概率事件（比如机器学习中，99% 都是向量和矩阵计算）")]),t._v(" "),r("li",[t._v("通过流水线提高性能，拆分 CPU 指令执行的过程，细化运行")]),t._v(" "),r("li",[t._v("通过预测提高性能")])]),t._v(" "),r("h2",{attrs:{id:"mips-指令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mips-指令"}},[t._v("#")]),t._v(" MIPS 指令")]),t._v(" "),r("p",[r("img",{attrs:{src:a(214),alt:"MIPS 指令"}})]),t._v(" "),r("p",[t._v("MIPS 指令是一个 32 位的整数，高 6 位叫操作码，代表这条指令具体是一条什么样的指令。")]),t._v(" "),r("ul",[r("li",[t._v("R 指令一般用来做算数和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。")]),t._v(" "),r("li",[t._v("I 指令通常是用在数据传输、条件分支以及在运算的时候使用的并非变量而是常数。这个时候没有了位移量和功能码，也没有了第三个寄存器，而是把这三个部分直接合并成了一个地址值或者一个常数。")]),t._v(" "),r("li",[t._v("J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。")])]),t._v(" "),r("h2",{attrs:{id:"cpu-内部寄存器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-内部寄存器"}},[t._v("#")]),t._v(" CPU 内部寄存器")]),t._v(" "),r("p",[r("img",{attrs:{src:a(215),alt:"CPU 内部寄存器"}})]),t._v(" "),r("ul",[r("li",[t._v("条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if...else 以及 for/while 这样的程序控制流程。")])]),t._v(" "),r("h2",{attrs:{id:"elf-文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#elf-文件"}},[t._v("#")]),t._v(" ELF 文件")]),t._v(" "),r("p",[r("img",{attrs:{src:a(216),alt:"ELF 文件格式"}})]),t._v(" "),r("p",[t._v("链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后在根据重定位表，把所有不确定要跳转地址的代码，根据符号表里存储的地址，进行一个修正。最后，把所有目标文件的对应段进行一个合并，变成了最终的可执行文件。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(217),alt:"ELF 文件格式"}})]),t._v(" "),r("p",[t._v("装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。")]),t._v(" "),r("p",[t._v("Linux 下可执行文件的格式是 "),r("code",[t._v("ELF")]),t._v("，Windows 下可执行文件的格式是 "),r("code",[t._v("PE")]),t._v("， Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("Linux 下著名的开源软件 Wine，就是通过兼容 PE 格式装载器，使得我们能直接在 Linux 下运行 Windows 程序。")]),t._v(" "),r("p",[t._v("Windows 的 WSL 可以解析和加载 ELF 格式的文件。")])]),t._v(" "),r("h2",{attrs:{id:"程序装载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序装载"}},[t._v("#")]),t._v(" 程序装载")]),t._v(" "),r("h3",{attrs:{id:"虚实转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚实转换"}},[t._v("#")]),t._v(" 虚实转换")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("我们把指令里用到的内存地址叫做"),r("strong",[t._v("虚拟内存地址")]),t._v("，实际在内存硬件里面的空间地址叫做"),r("strong",[t._v("物理内存地址")]),t._v("。")])]),t._v(" "),r("p",[t._v("对于任何一个程序来说，它看到的都是同样的内存地址，我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所有我们只需要维护映射关系的起始地址和对应的空间大小就可以了。")]),t._v(" "),r("h3",{attrs:{id:"内存分段-页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分段-页"}},[t._v("#")]),t._v(" 内存分段/页")]),t._v(" "),r("p",[r("img",{attrs:{src:a(218),alt:"内存分段"}})]),t._v(" "),r("p",[t._v("如上图所示，内存分段会带来内存碎片的问题，解决办法是"),r("strong",[t._v("内存交换")]),t._v("。")]),t._v(" "),r("p",[t._v("硬盘的访问速度要比内存慢很多，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。解决的办法是"),r("strong",[t._v("内存分页")]),t._v("，在需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点。")]),t._v(" "),r("p",[t._v("分段是将一整段连续连续的空间映射给程序，分页是把整个物理内存空间切成一段段固定尺寸的大小。对应的应用程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间称为"),r("strong",[t._v("页")]),t._v("。从虚拟内存到物理内存的映射，不再是拿整段连续内存的物理地址，而是按照一个一个页来的。在 Linux 下，我们通常只设置成 4KB。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(219),alt:"内存分页"}})]),t._v(" "),r("p",[t._v("由于内存空间都是预先划分好的，也就没有了不能使用的碎片，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其它程序通过内存交换释放出一些内存页来，一次性写入磁盘的也只有少数的一个页或者几个页。")]),t._v(" "),r("p",[t._v("更进一步，分页的方式使得我们在装载程序的时候，不再需要一次性把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。")]),t._v(" "),r("h2",{attrs:{id:"动态链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[t._v("#")]),t._v(" 动态链接")]),t._v(" "),r("p",[r("img",{attrs:{src:a(220),alt:"动态链接"}})]),t._v(" "),r("p",[t._v("想要在程序运行的时候共享代码，有一定的要求，就是这些机器码必须是"),r("strong",[t._v("地址无关")]),t._v("的，即编译出来的共享库文件的指令代码是地址无关码。常见的地址相关的代码：")]),t._v(" "),r("ul",[r("li",[t._v("绝对地址代码")]),t._v(" "),r("li",[t._v("利用重定位表的代码")])]),t._v(" "),r("h3",{attrs:{id:"plt-和-got"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#plt-和-got"}},[t._v("#")]),t._v(" PLT 和 GOT")]),t._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.coursera.org/learn/jisuanji-zucheng",target:"_blank",rel:"noopener noreferrer"}},[t._v("coursera 公开课《计算机组成》"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.bilibili.com/video/av24540152/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSAPP 深入理解计算机系统"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=_.exports}}]);